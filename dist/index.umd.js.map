{"version":3,"file":"index.umd.js","sources":["../src/index.tsx"],"sourcesContent":["import React from \"react\";\nimport { Swipeable, EventData } from \"react-swipeable\";\n\nexport interface IProps {\n  className?: string;\n  classNameInner?: string;\n  align?: \"top\" | \"center\" | \"bottom\";\n  padding?: number;\n  itemsPerSwipe?: number;\n  autoPlay?: boolean;\n  autoPlayDuration?: number;\n  infinite?: boolean;\n  disableSlowSwipe?: boolean;\n}\n\ninterface IState {\n  left: number;\n  disableTransition: boolean;\n}\n\nconst defaultPrependNumber = 4;\n\nfunction getItemsCountByVelocity(velocity: number) {\n  return Math.round(velocity * 3);\n}\n\nfunction isSlowSwipe(velocity: number) {\n  return velocity < 0.3;\n}\n\nexport class Carousel extends React.Component<IProps, IState> {\n  private containerEl?: HTMLDivElement | null;\n  private innerEl?: HTMLDivElement | null;\n  private wrapperEls: (HTMLElement | null)[] = [];\n  currentIndex = 0;\n  private left = 0;\n  private maxIndex?: number;\n  private autoPlayTimer?: any;\n  private resetIndexTimer?: any;\n  private sliderWidth?: { innerElWidth: number; containerElWidth: number } | false;\n  private originLeft?: number;\n\n  constructor(props: IProps) {\n    super(props);\n\n    this.state = {\n      left: 0,\n      disableTransition: false,\n    };\n  }\n\n  componentDidMount() {\n    this.init();\n  }\n\n  init() {\n    if (Array.isArray(this.props.children)) {\n      if (this.props.infinite) {\n        const childrenLength = this.props.children.length;\n\n        // it could be refactor by other better algorithm\n        setTimeout(() => {\n          this.slideToIndexWithoutTransition(childrenLength * defaultPrependNumber);\n        }, 3000);\n      }\n\n      this.resetAutoPlayTimer();\n    }\n  }\n\n  render() {\n    const { children, infinite, disableSlowSwipe, className, classNameInner, align = \"center\" } = this.props;\n    if (!Array.isArray(children)) {\n      return null;\n    }\n\n    const newChildren = !infinite ? children : [];\n\n    if (infinite) {\n      for (let i = 0; i < defaultPrependNumber * 2 + 1; i++) {\n        newChildren.push(...children);\n      }\n    }\n\n    const padding = this.getPadding();\n    const childrenLength = newChildren.length;\n    const alignItems = align === \"top\" ? \"flex-start\" : align === \"center\" ? \"center\" : \"flex-end\";\n\n    return (\n      <Swipeable\n        preventDefaultTouchmoveEvent={true}\n        onSwiping={!disableSlowSwipe ? this.handleSwiping : undefined}\n        onSwiped={!disableSlowSwipe ? this.handleSwiped : undefined}\n        onSwipedLeft={this.handleSwipedLeft}\n        onSwipedRight={this.handleSwipedRight}\n      >\n        <div className={className} ref={(el) => (this.containerEl = el)} style={{ overflow: \"hidden\" }}>\n          <div\n            className={classNameInner}\n            ref={(el) => (this.innerEl = el)}\n            style={{\n              float: \"left\",\n              display: \"flex\",\n              flexWrap: \"nowrap\",\n              alignItems: alignItems,\n              transform: `translateX(${this.state.left}px)`,\n              transition: !this.state.disableTransition ? \"transform 0.5s ease-out\" : \"none\",\n            }}\n          >\n            {newChildren.map((child, index) => {\n              return (\n                <div\n                  key={index}\n                  style={{\n                    display: \"flex\",\n                    marginRight: index !== childrenLength - 1 ? padding || 10 : 0,\n                  }}\n                  ref={(el) => {\n                    this.wrapperEls[index] = el;\n                  }}\n                >\n                  {child}\n                </div>\n              );\n            })}\n          </div>\n          <div style={{ clear: \"both\", height: 0 }} />\n        </div>\n      </Swipeable>\n    );\n  }\n\n  private getPadding() {\n    return this.props.padding != null ? this.props.padding : 10;\n  }\n\n  private handleSwiping = (data: EventData) => {\n    if (this.sliderWidth == null) {\n      this.sliderWidth = this.getSliderWidth();\n    }\n\n    if (this.sliderWidth === false) {\n      return;\n    }\n\n    if (!isSlowSwipe(data.velocity)) {\n      return;\n    }\n\n    this.clearAutoPlayTimer();\n\n    if (this.originLeft == null) {\n      this.originLeft = this.left;\n    }\n\n    const newLeft = this.originLeft - data.deltaX;\n    const { innerElWidth, containerElWidth } = this.sliderWidth!;\n    const minLeft = containerElWidth - innerElWidth;\n\n    this.left = newLeft > 0 ? 0 : newLeft < minLeft ? minLeft : newLeft;\n    this.setState({ left: this.left, disableTransition: true });\n  };\n\n  private handleSwiped = (data: EventData) => {\n    const sliderWidth = this.sliderWidth;\n\n    if (this.sliderWidth != null) {\n      this.sliderWidth = undefined;\n    }\n\n    if (sliderWidth === false) {\n      return;\n    }\n\n    if (!isSlowSwipe(data.velocity)) {\n      return;\n    }\n\n    this.resetAutoPlayTimer();\n\n    this.originLeft = undefined;\n\n    const childrenLength = this.wrapperEls.length;\n    let totalOffset = 0;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const wrapperEl = this.wrapperEls[i];\n\n      if (wrapperEl) {\n        const elWidth = wrapperEl.getBoundingClientRect().width + this.getPadding();\n        totalOffset += elWidth;\n\n        if (-totalOffset < this.left) {\n          const isMoreThanAHalf = totalOffset + this.left < elWidth / 2;\n          const newIndex = isMoreThanAHalf ? i + 1 : i;\n\n          this.slideToNIndex({ index: newIndex, disableTransition: false });\n\n          break;\n        }\n      }\n    }\n  };\n\n  private handleSwipedLeft = (data: EventData) => {\n    if (isSlowSwipe(data.velocity)) {\n      return;\n    }\n\n    const increasedIndex =\n      this.props.itemsPerSwipe != null ? this.props.itemsPerSwipe : getItemsCountByVelocity(data.velocity);\n    const index = this.currentIndex + increasedIndex;\n    const forwardIndex = index > this.wrapperEls.length - 1 ? this.wrapperEls.length - 1 : index;\n\n    this.resetAutoPlayTimer();\n    this.slideToNIndex({ index: forwardIndex, cb: this.resetIndex });\n  };\n\n  private handleSwipedRight = (data: EventData) => {\n    if (isSlowSwipe(data.velocity)) {\n      return;\n    }\n\n    const increasedIndex =\n      this.props.itemsPerSwipe != null ? this.props.itemsPerSwipe : getItemsCountByVelocity(data.velocity);\n    const index = this.currentIndex - increasedIndex;\n    const backToIndex = index < 0 ? 0 : index;\n\n    this.resetAutoPlayTimer();\n    this.slideToNIndex({ index: backToIndex, cb: this.resetIndex });\n  };\n\n  private getSliderWidth() {\n    if (this.innerEl == null || this.containerEl == null) {\n      return false;\n    }\n\n    const innerElWidth = this.innerEl.getBoundingClientRect().width;\n    const containerElWidth = this.containerEl.getBoundingClientRect().width;\n\n    if (innerElWidth < containerElWidth) {\n      return false;\n    }\n\n    return { innerElWidth, containerElWidth };\n  }\n\n  private resetIndex = () => {\n    if (!this.props.infinite) {\n      return;\n    }\n\n    clearTimeout(this.resetIndexTimer);\n\n    // waiting transition ended\n    this.resetIndexTimer = setTimeout(() => {\n      if (Array.isArray(this.props.children)) {\n        const childrenLength = this.props.children.length;\n        const originIndex = childrenLength * defaultPrependNumber;\n        const newIndex = (this.currentIndex % childrenLength) + originIndex;\n\n        if (newIndex !== this.currentIndex) {\n          this.slideToIndexWithoutTransition(newIndex);\n        }\n      }\n    }, 500);\n  };\n\n  slideToNIndex = (options: { index: number; cb?: () => void; disableTransition?: boolean }) => {\n    const { index, cb, disableTransition } = options;\n    const sliderWidth = this.getSliderWidth();\n    if (sliderWidth === false) {\n      return;\n    }\n\n    const { containerElWidth, innerElWidth } = sliderWidth;\n    const minLeft = containerElWidth - innerElWidth;\n    let totalOffset = 0;\n    let maxIndex;\n\n    for (let i = 0; i < index; i++) {\n      const wrapperEl = this.wrapperEls[i];\n\n      if (wrapperEl) {\n        const elWidth = wrapperEl.getBoundingClientRect().width + this.getPadding();\n        totalOffset += elWidth;\n\n        if (-totalOffset < minLeft) {\n          maxIndex = i + 1;\n\n          break;\n        }\n      }\n    }\n\n    if (maxIndex != null) {\n      this.left = minLeft;\n    } else {\n      this.left = -totalOffset;\n    }\n\n    this.maxIndex = maxIndex;\n    this.currentIndex = maxIndex != null ? maxIndex : index;\n    this.setState({ left: this.left, disableTransition: disableTransition != null ? disableTransition : false }, cb);\n  };\n\n  slideToIndexWithoutTransition(index: number) {\n    this.slideToNIndex({\n      index,\n      disableTransition: true,\n    });\n  }\n\n  clearAutoPlayTimer() {\n    clearInterval(this.autoPlayTimer);\n  }\n\n  resetAutoPlayTimer() {\n    if (!this.props.autoPlay) {\n      return;\n    }\n\n    this.clearAutoPlayTimer();\n\n    this.autoPlayTimer = setInterval(() => {\n      if (this.maxIndex == null) {\n        this.slideToNIndex({ index: this.currentIndex + 1 });\n      } else {\n        this.slideToNIndex({ index: 0 });\n      }\n    }, Math.round((this.props.autoPlayDuration || 3) * 1000));\n  }\n}\n"],"names":["const","defaultPrependNumber","getItemsCountByVelocity","velocity","Math","round","isSlowSwipe","constructor","props","data","this","sliderWidth","getSliderWidth","clearAutoPlayTimer","originLeft","left","newLeft","deltaX","minLeft","setState","disableTransition","undefined","resetAutoPlayTimer","childrenLength","wrapperEls","length","totalOffset","i","wrapperEl","elWidth","getBoundingClientRect","width","getPadding","slideToNIndex","index","increasedIndex","itemsPerSwipe","currentIndex","forwardIndex","cb","resetIndex","backToIndex","infinite","clearTimeout","resetIndexTimer","setTimeout","Array","isArray","children","newIndex","slideToIndexWithoutTransition","options","containerElWidth","maxIndex","state","componentDidMount","init","render","newChildren","let","push","padding","React","Swipeable","preventDefaultTouchmoveEvent","onSwiping","disableSlowSwipe","handleSwiping","onSwiped","handleSwiped","onSwipedLeft","handleSwipedLeft","onSwipedRight","handleSwipedRight","className","ref","el","containerEl","style","overflow","classNameInner","innerEl","float","display","flexWrap","alignItems","align","transform","transition","map","child","key","marginRight","clear","height","innerElWidth","clearInterval","autoPlayTimer","autoPlay","setInterval","autoPlayDuration","Component"],"mappings":"4UAoBAA,IAAMC,EAAuB,EAE7B,SAASC,EAAwBC,UACxBC,KAAKC,MAAiB,EAAXF,GAGpB,SAASG,EAAYH,UACZA,EAAW,0BAelBI,WAAYC,0BACJA,mBAVqC,qBAC9B,YACA,8BAqGUC,MACC,MAApBC,EAAKC,gBACFA,YAAcD,EAAKE,mBAGD,IAArBF,EAAKC,aAIJL,EAAYG,EAAKN,aAIjBU,qBAEkB,MAAnBH,EAAKI,eACFA,WAAaJ,EAAKK,UAGnBC,EAAUN,EAAKI,WAAaL,EAAKQ,SACIP,EAAKC,YAC1CO,sCAEDH,KAAOC,EAAU,EAAI,EAAIA,EAAUE,EAAUA,EAAUF,IACvDG,SAAS,CAAEJ,KAAML,EAAKK,KAAMK,mBAAmB,iCAG9BX,OAChBE,EAAcD,EAAKC,eAED,MAApBD,EAAKC,gBACFA,iBAAcU,IAGD,IAAhBV,GAICL,EAAYG,EAAKN,aAIjBmB,uBAEAR,gBAAaO,UAEZE,EAAiBb,EAAKc,WAAWC,OACnCC,EAAc,EAETC,EAAI,EAAGA,EAAIJ,EAAgBI,IAAK,KACjCC,EAAYlB,EAAKc,WAAWG,MAE9BC,EAAW,KACPC,EAAUD,EAAUE,wBAAwBC,MAAQrB,EAAKsB,kBAC/DN,GAAeG,GAEInB,EAAKK,KAAM,GAIvBkB,cAAc,CAAEC,MAHGR,EAAchB,EAAKK,KAAOc,EAAU,EACzBF,EAAI,EAAIA,EAELP,mBAAmB,8CAQrCX,OACtBH,EAAYG,EAAKN,eAIfgC,EACwB,MAA5BzB,EAAKF,MAAM4B,cAAwB1B,EAAKF,MAAM4B,cAAgBlC,EAAwBO,EAAKN,UACvF+B,EAAQxB,EAAK2B,aAAeF,EAC5BG,EAAeJ,EAAQxB,EAAKc,WAAWC,OAAS,EAAIf,EAAKc,WAAWC,OAAS,EAAIS,IAElFZ,uBACAW,cAAc,CAAEC,MAAOI,EAAcC,GAAI7B,EAAK8B,+CAGxB/B,OACvBH,EAAYG,EAAKN,eAIfgC,EACwB,MAA5BzB,EAAKF,MAAM4B,cAAwB1B,EAAKF,MAAM4B,cAAgBlC,EAAwBO,EAAKN,UACvF+B,EAAQxB,EAAK2B,aAAeF,EAC5BM,EAAcP,EAAQ,EAAI,EAAIA,IAE/BZ,uBACAW,cAAc,CAAEC,MAAOO,EAAaF,GAAI7B,EAAK8B,0CAmB7C9B,EAAKF,MAAMkC,WAIhBC,aAAajC,EAAKkC,mBAGbA,gBAAkBC,yBACjBC,MAAMC,QAAQrC,EAAKF,MAAMwC,UAAW,KAChCzB,EAAiBb,EAAKF,MAAMwC,SAASvB,OAErCwB,EAAYvC,EAAK2B,aAAed,EADlBA,EAAiBtB,EAGjCgD,IAAavC,EAAK2B,gBACfa,8BAA8BD,KAGtC,mCAGYE,GACPjB,2CACFvB,EAAcD,EAAKE,qBACL,IAAhBD,OAIIyC,IAGJC,EAFEnC,oCACFQ,EAAc,EAGTC,EAAI,EAAGA,EAAIO,EAAOP,IAAK,KACxBC,EAAYlB,EAAKc,WAAWG,MAE9BC,KAEFF,GADgBE,EAAUE,wBAAwBC,MAAQrB,EAAKsB,cAG5Cd,EAAS,CAC1BmC,EAAW1B,EAAI,WAQdZ,KADS,MAAZsC,EACUnC,GAECQ,IAGV2B,SAAWA,IACXhB,aAA2B,MAAZgB,EAAmBA,EAAWnB,IAC7Cf,SAAS,CAAEJ,KAAML,EAAKK,KAAMK,kBAAwC,MAArBA,GAA4BA,GAA6BmB,UAlQxGe,MAAQ,CACXvC,KAAM,EACNK,mBAAmB,mGAIvBmC,kCACOC,oBAGPA,8BACMV,MAAMC,QAAQrC,KAAKF,MAAMwC,UAAW,IAClCtC,KAAKF,MAAMkC,SAAU,KACjBnB,EAAiBb,KAAKF,MAAMwC,SAASvB,OAG3CoB,wBACOK,8BAA8B3B,EAAiBtB,IACnD,UAGAqB,mCAITmC,+BACgG/C,KAAKF,kHAAlB,WAC5EsC,MAAMC,QAAQC,UACV,SAGHU,EAAehB,EAAsB,GAAXM,KAE5BN,MACGiB,IAAIhC,EAAI,EAAGA,EAA2B,EAAvB1B,EAA2B,EAAG0B,IAChD+B,EAAYE,aAAQZ,OAIlBa,EAAUnD,KAAKsB,aACfT,EAAiBmC,EAAYjC,cAIjCqC,gBAACC,aACCC,8BAA8B,EAC9BC,UAAYC,OAAwC7C,EAArBX,KAAKyD,cACpCC,SAAWF,OAAuC7C,EAApBX,KAAK2D,aACnCC,aAAc5D,KAAK6D,iBACnBC,cAAe9D,KAAK+D,mBAEpBX,uBAAKY,UAAWA,EAAWC,aAAMC,UAAQlE,EAAKmE,YAAcD,GAAKE,MAAO,CAAEC,SAAU,WAClFjB,uBACEY,UAAWM,EACXL,aAAMC,UAAQlE,EAAKuE,QAAUL,GAC7BE,MAAO,CACLI,MAAO,OACPC,QAAS,OACTC,SAAU,SACVC,WAlBmB,QAAVC,EAAkB,aAAyB,WAAVA,EAAqB,SAAW,WAmB1EC,wBAAyB7E,KAAK4C,iBAC9BkC,WAAa9E,KAAK4C,MAAMlC,kBAAgD,OAA5B,4BAG7CsC,EAAY+B,aAAKC,EAAOxD,UAErB4B,uBACE6B,IAAKzD,EACL4C,MAAO,CACLK,QAAS,OACTS,YAAa1D,IAAUX,EAAiB,EAAIsC,GAAW,GAAK,GAE9Dc,aAAMC,KACCpD,WAAWU,GAAS0C,IAG1Bc,MAKT5B,uBAAKgB,MAAO,CAAEe,MAAO,OAAQC,OAAQ,oBAMrC9D,6BACuB,MAAtBtB,KAAKF,MAAMqD,QAAkBnD,KAAKF,MAAMqD,QAAU,gBAmGnDjD,6BACc,MAAhBF,KAAKuE,SAAuC,MAApBvE,KAAKmE,mBACxB,MAGHkB,EAAerF,KAAKuE,QAAQnD,wBAAwBC,MACpDqB,EAAmB1C,KAAKmE,YAAY/C,wBAAwBC,cAE9DgE,EAAe3C,IAIZ,cAAE2C,mBAAc3C,gBA8DzBF,uCAA8BhB,QACvBD,cAAc,OACjBC,EACAd,mBAAmB,iBAIvBP,8BACEmF,cAActF,KAAKuF,4BAGrB3E,yCACOZ,KAAKF,MAAM0F,gBAIXrF,0BAEAoF,cAAgBE,yBAEZlE,cADc,MAAjBvB,EAAK2C,SACY,CAAEnB,MAAOxB,EAAK2B,aAAe,GAE7B,CAAEH,MAAO,KAE7B9B,KAAKC,MAA2C,KAApCK,KAAKF,MAAM4F,kBAAoB,UA5SpBtC,EAAMuC"}